# ===============================================
# 1. CLASE PERSONA
# ===============================================
class Persona:
    def __init__(self, nombre, edad):
        # Constructor para inicializar atributos
        self.nombre = nombre
        self.edad = edad
    
    def saludar(self):
        # Método para imprimir un saludo
        print(f"Hola, mi nombre es {self.nombre} y tengo {self.edad} años")

# Uso de la clase Persona
p1 = Persona("Ana", 20)
p1.saludar()
print("-" * 20)

# ===============================================
# 2. CLASE CALCULADORA
# ===============================================
class Calculadora:
    # Métodos para operaciones básicas
    def sumar(self, a, b): 
        return a + b
    
    def restar(self, a, b):
        return a - b  # Corregido: la resta completa
    
    def multiplicar(self, a, b): 
        return a * b
    
    def dividir(self, a, b):
        if b == 0:
            return "Error: división entre cero"
        return a / b

# Uso de la clase Calculadora
calc = Calculadora()
print(f"Suma (5+3): {calc.sumar(5, 3)}")
print("-" * 20)

# ===============================================
# 3. CLASE RECTANGULO
# ===============================================
class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura
    
    def area(self):
        return self.base * self.altura # Corregido: multiplicación explícita
    
    def perimetro(self):
        return 2 * (self.base + self.altura) # Corregido: multiplicación explícita

# Uso de la clase Rectangulo
r1 = Rectangulo(5, 3)
print(f"Área y Perímetro (base 5, altura 3): {r1.area()}, {r1.perimetro()}")
print("-" * 20)

# ===============================================
# 4. CLASES ANIMAL, PERRO, GATO (Herencia y Polimorfismo)
# ===============================================
class Animal:
    def __init__(self, nombre):
        self.nombre = nombre
    
    def hablar(self): 
        pass # Método base, se redefine en subclases

class Perro(Animal):
    def hablar(self): 
        return "Guau!"

class Gato(Animal):
    def hablar(self): 
        return "Miau!"

# Uso de la jerarquía Animal
perro = Perro("Firulais")
print(f"El perro dice: {perro.hablar()}")
print("-" * 20)

# ===============================================
# 5. CLASE CUENTABANCARIA
# ===============================================
class CuentaBancaria:
    def __init__(self, titular, saldo=0):
        self.titular = titular
        self.saldo = saldo
    
    def depositar(self, monto):
        self.saldo += monto # Corregido: asignación compuesta
        print(f"Depósito de {monto} realizado.")
    
    def retirar(self, monto):
        if monto > self.saldo:
            print("Fondos insuficientes")
        else:
            self.saldo -= monto # Corregido: asignación compuesta
            print(f"Retiro de {monto} realizado.")
    
    def mostrar_saldo(self):
        print(f"Saldo actual: {self.saldo}")

# Uso de la clase CuentaBancaria
cuenta = CuentaBancaria("Carlos", 1000)
cuenta.depositar(500)
cuenta.mostrar_saldo()
print("-" * 20)

# ===============================================
# 6. CLASE ALUMNO
# ===============================================
class Alumno:
    def __init__(self, nombre, calificaciones):
        self.nombre = nombre
        self.calificaciones = calificaciones
    
    def promedio(self):
        # Calcula el promedio de la lista de calificaciones
        return sum(self.calificaciones) / len(self.calificaciones)

# Uso de la clase Alumno
al = Alumno("Ana", [9, 8, 10])
print(f"El promedio de {al.nombre} es: {al.promedio()}")
print("-" * 20)

# ===============================================
# 7. CLASE AGENDA
# ===============================================
class Agenda:
    def __init__(self):
        self.contactos = [] # Lista para almacenar tuplas (nombre, tel)
    
    def agregar(self, nombre, tel):
        self.contactos.append((nombre, tel))
    
    def buscar(self, nombre):
        for c in self.contactos:
            if c[0] == nombre:
                return c
        return "No encontrado"
    
    def mostrar(self):
        print("--- Contactos ---")
        for c in self.contactos:
            print(c)

# Uso de la clase Agenda
agenda = Agenda()
agenda.agregar("Ana", "1111")
agenda.agregar("Beto", "2222")
agenda.mostrar()
print(f"Buscar a Ana: {agenda.buscar('Ana')}")
print("-" * 20)

# ===============================================
# 8. CLASE PRODUCTO (Ejemplo de atributo privado/interno)
# ===============================================
class Producto:
    def __init__(self, nombre, precio):
        self.nombre = nombre
        self.precio = precio
        self._descuento = 0.1 # Atributo marcado como interno con _
    
    def precio_final(self):
        # Calcula el precio con el 10% de descuento
        return self.precio * (1 - self._descuento) # Corregido: cálculo de descuento

# Uso de la clase Producto
p1 = Producto("Laptop", 15000)
print(f"El precio final de {p1.nombre} es: {p1.precio_final()}")
print("-" * 20)

# ===============================================
# 9. CLASES FIGURA, CIRCULO, CUADRADO (Polimorfismo para área)
# ===============================================
class Figura:
    def area(self): 
        pass # Método a implementar en las subclases

class Circulo(Figura):
    def __init__(self, radio):
        self.radio = radio
    
    def area(self):
        # Usamos 3.1416 como Pi
        return 3.1416 * (self.radio**2) # Corregido: uso de exponente

class Cuadrado(Figura):
    def __init__(self, lado):
        self.lado = lado
    
    def area(self):
        return self.lado**2

# Uso con Polimorfismo
figuras = [Circulo(5), Cuadrado(4)]
print("Cálculo de Áreas por Polimorfismo:")
for f in figuras:
    print(f"Área: {f.area()}")
print("-" * 20)

# ===============================================
# 10. CLASE CARRO
# ===============================================
class Carro:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo
        self.velocidad = 0
    
    def acelerar(self, cantidad):
        self.velocidad += cantidad # Corregido: asignación compuesta
        print(f"Acelerando a {self.velocidad} km/h")
    
    def frenar(self, cantidad):
        # Asegura que la velocidad no sea negativa
        self.velocidad = max(0, self.velocidad - cantidad) # Corregido: asignación y max(0)
        print(f"Frenando a {self.velocidad} km/h")
    
    def mostrar_velocidad(self):
        print(f"Velocidad actual: {self.velocidad}")

# Uso de la clase Carro
carro = Carro("Nissan", "Versa")
carro.acelerar(20)
carro.frenar(5)
carro.mostrar_velocidad()
print("-" * 20)
